/*
 * brk関数とsbrk関数は現代的な仮想メモリ管理が現れる以前の古いインターフェイスです。mallocで利用されています
 * brkとsbrkは追加メモリを確保するための利用されるmmapのようなインターフェイスです。
 *
 * sbrk()システムコールは、プロセスが取得したメモリ領域を単純に拡大しようとしますが、MMUのないCPUの場合には
 * 仮想メモリ機構を扱うことができないため、他のプロセスが使っているメモリ領域にぶつかってしまう可能性があります。
 * そのため、MMUのないCPU上でsbrk()システムコールを使用するのは危険です。mallocを使うglibcはMMUのないCPUでは使用できません
 * なお、mmap()システムコールはsbrk()と異なりプロセスが取得したメモリ領域とは全く別の空いているメモリ領域から取得しようとするので、MMUがないCPUでも利用可能です。
 * 
 * REFERENCE: http://capm-network.com/?tag=C%E8%A8%80%E8%AA%9E%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%82%B3%E3%83%BC%E3%83%AB-sbrk
 */
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int main() {
  char *s;


  // sbrkはヒープ領域のブレーク値を加算して変更します。
  // プロセスのメモリ未割り当て領域を「ヒープ」といい、ヒープ上の未割り当てメモリの先頭アドレスを「ブレーク値」といいます。
  //
  // sbrkシステムコールはブレーク値をバイト数指定で加算します。 
  //    整数を指定してsbrkを実行すると、ヒープ領域にメモリを動的に割り当てます。
  //    負数を指定してsbrkを実行すると、その分のメモリは解放されます。 

  // [memo] "warning: comparison between pointer and integer [enabled by default]"のwarningエラーのため(void*)でキャストする
  if ((s = sbrk(13)) == (void*)-1) {  // 13 = "Hello World\n"
    perror("sbrk");
    return 1;
  }

  strcpy(s, "Hello World\n");
  write(1, s, 12);

  // brkシステムコール及びsbrkシステムコールを利用してブレーク値を変更することで、メモリの割り当てと解放を行うことができます。 
  // 
  // brkシステムコールはプロセスに新しいブレーク値を任意に設定します。 
  //    指定したブレーク値が現在のブレーク値より大きい場合には、ヒープ領域にメモリを割り当てます。
  //    指定したブレーク値が現在のブレーク値より小さい場合には、ヒープ領域に動的に割り当てられたメモリを解放します。 
  if (brk(s) < 0) {
    perror("brk");
    return 1;
  }

  return 0;
}
