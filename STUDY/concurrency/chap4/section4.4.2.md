# 概略
## 4.4.2 Synchronizing operations with message passing
CSP(Communicating Sequential Process)といった考え方が登場し、もし同期処理が存在しなければ、スレッドは本質的に独立していることになり、分割したアプリケーションとして記述されているのと同等である。
本当のCSPはすべてのコミュニケーションでメッセージキューを通すことで、共有データを持たない。

ATMによる具体例のコードによるメッセージパッシングの説明がほとんどで、Figure4.3に関する説明が大部分を占めている。
共有するデータが存在しない場合、受け取ったメッセージに対してどのように振る舞いをするのかといった根拠に対して、各種データは完全に独立しているという根拠となる。
メッセージパッシングは共有データではなく、ある初期状態を元にして何か処理が行われたら別スレッドに対して処理をつたえる仕組み。
C++ではアドレス空間を共有するので、実質的にはアプリケーションやライブラリなどで隠蔽されることとなる。
appendix Cで完全な実装を定義している。
ATMロジックのためのこの状態マシンはシングルスレッドで稼働する。また、銀行への操作やターミナル操作は分割したスレッドで機能する。この種のプログラム設計はActorモデルと呼ばれます。


## 4.5 Summary
スレッド間の同期操作はconcurrency利用しているアプリケーションを記述することにとって重要な一部です。

この章では様々な同期方法をカバーした。基礎的な状態変数から、future, promises, packaged tasksなど

また、同期問題へのアプローチ方法を議論してきた。
関数型プログラミングは外部要因というよりも、入力されたデータに完全に依存することを学んだ。
スレッド間コミュニケーション(メッセージパッシング)は仲介としてメッセージサブシステムを通して非同期メッセージを経由します。

C++ではhigh-levelな沢山の機能を利用することについて議論してきました。
続いては、low-velelな機能である「C++ memory model and atomic operations」についてみていくことにします。


# 以下は4.4.2詳細

###
CSP(Communicating Sequential Process) の考え方は単純である: 共有するデータが存在しない場合、受け取ったメッセージに対してどのように振る舞いをするのかといった根拠に対して、各種データは完全に独立しているという根拠となります。
各種スレッドは効率的なステートマシンとなります。: つまり、スレッドがメッセージを受信したら、ある種の規則にもとづいて状態を更新して、１つもしくはそれ以上のメッセージを他のスレッドに送信するかもしれません。処理は初期状態に依存して行われます。
そのようなスレッドを記述する１つの方法はこれを正規化し、そして有限の状態マシンモデルを実装することです。 しかし、これだけが方法となるわけではありません。例えば、ステートマシンはアプリケーション構造中において暗黙的になります。(イマイチよくわかっていない)

与えられたシナリオでどのメソッドがうまく機能するか(与えられたシナリオというのは状況による正確な振る舞い要求やプログラミングチームの専門的知識に基づくことに依存する)
しかし、あなたは各種スレッドを実装することを選ぶかもしれない。
独立したプロセスの分離は共有データの同期からの複雑な処理を削除する可能性を持っていて、それゆえにプログラムを容易にし、バグを少なくする

###
本当のCSPはすべてのコミュニケーションでメッセージキューを通すことで、共有データを持たない。
しかし、C++スレッドはアドレス空間を共有することができるので、この要求を強制することはできません。
そういった場合には規制が入ることによる：つまり、アプリケーションやライブラリ著者では、スレッド間でデータを共有していないことを保証する責任がある。
もちろん、メッセージキューはスレッドがコミュニケーションするために共有しなければならない、しかし、詳細はライブラリ中にラッピングされています。

###
ATMのためのコードを実装することを想像してみましょう。
このコードはお金を引き出そうとする人や銀行に関連する操作を取り扱わなければならない。
(上記で銀行に関連するというのは、)個人カードの受け入れ、適切なメッセージの表示、keyを押下することの取扱、お金の発行、カードを戻すなどの物理的機械操作の受け入れ制御も含む

###
すべてを扱うための１つの方法は、３つの独立したスレッドに分割することである。
- 1つは、物理的な機械を扱うための
- 1つは、ATM Logicのための
- 1つは、銀行と通信するための
これらのスレッドは、データを共有するというよりは純粋にメッセージを送りあうことによってコミュニケーションを取っています。
たとえば、機械を扱うスレッドはカードを入れたり、ボタンが押下された際にlogicスレッドにメッセージを送信します。そして、Logicスレッドは機械スレッドにどれだけのお金がおろされたかなどのメッセージを送るかもしれません。

###
ATMロジックをモデル化すための１つの方法は、ステートマシンとしての方法があるだろう。
それぞれの状態中では、スレッドは受け入れメッセージをwaitしているかもしれません。そして、それを元に処理をしているかもしれません。
これは結果として新しい状態に遷移したり、サイクリックな周期的な継続処理が行われるかもしれません。
単純な実装に含まれる状態は4.3で定義されています。

この単純化された実装においては、
- システムはcardがinsertされるまで待ちます。
- 一度、カードが投入されたら、ユーザがPINを入力するまで待ちます。
- 十分なdigitsが入力されたら、PIN認証が認証されます。
- PINがOKじゃなかったら、終了し、カードをcustomerに返却し、他の誰かがカードを投入するまでまた待ちます。
- もし、PINがOKならば、取引の中止やお金の引き落としを選択するのを待ちます
- もし、キャンセルが選択されたなら、終了し、カードを出します。
- もし、引き落としが選択されたなら、現金を発行する前に銀行からの確認を待つ。そして、カードを戻すか、"insufficient funds"メッセージを表示し、カードを戻す。
明らかに、本物のATMはもっと複雑な処理をしていますが、これで図を説明するのには十分である。

### 
ATMロジックのための設計を行ってきたので、それぞれの状態を表すためにメンバー関数を持つクラスを実装することができます。
それぞれのメンバー関数は入ってくるメッセージの特定のセットを待つことができ、届いたらそれらのメッセージを扱います。他の状態へのスイッチとなる可能性もあります。

区別されたメッセージタイプは区別されたstructで表されます。
Listing 4.15はmain loopを持ち、カードが入力されるまで待つという初期状態を持つシステムにおいてATMロジックの単純な実装の一部を表しています。

###
見てわかるように、メッセージパッシングのためのすべての必要な同期処理はすべてメッセージパッシングライブラリの中に隠されています。
(基礎的な実装はappendix Cでこの例の完全なコードの実装とともに記されています)

###
すでに述べられているように、ここで述べられている実装は全体的にATMに必要となる本当のロジックからは単純化されている。
しかし、メッセージパッシングスタイルに対するプログラミングへのfeelingを与える。
どのような時にメッセージを受け取るか、どのメッセージを送るべきかといった、syncやconcurrencyの問題を考える必要はない。

このATMロジックのためのこの状態マシンはシングルスレッドで稼働する。銀行への操作やターミナル操作は分割した個々のスレッドで機能する。
この種のプログラム設計はActorモデルと呼ばれます。
システム中には複数のactorが存在しています。それらはtaskを他のスレッドに伝えるためにメッセージを送信します。
そして、直接送られてきたメッセージ以外の共有データが存在しません。

### 
実行は⑤run()メンバー関数で始まる。その時の初期状態はwaiting_for_car⑥に固定される。
そして、それからcurrent stateで表されるメンバー関数を繰り返し実行する⑦。
状態関数はatmクラスの単純なメンバー関数です。
waiting_for_card状態関数①もまた単純です。「waiting for card」メッセージを表示するため(②)のI/Fにメッセージを送ります。そして、それを扱うためのメッセージを待ちます③
これを扱かわれる唯一のメッセージはcard_insertedメッセージです。そこでは、lambda関数で扱われます(④)
handle()関数にどんな関数や関数オブジェクトにメッセージをパスすることができる。このような単純なケースだとlambda()を使うのが簡単です。
handle()関数はwait関数のチェーンとなっていることに注意する。もし、メッセージを受け取ったがどのタイプにもまっちしない場合、捨てられる。そして、メッセージがマッチングされるまでスレッドは待ち続けます。

### 
lambda関数自体はメンバー変数にカードからのアカウント情報をキャッシュして、現在のPINをクリアして、ユーザーにPIN入力を促すようなメッセージを表示するためのメッセージを送る。そして、"getting PIN"状態を変化させる。
メッセージハンドラが完了したら、状態関数はreturnを返し、そして、main loopは新しい状態関数を呼びます。

###
今回、３つのメッセージタイプを扱うことができます。
wait()関数は３つの①、②、③のhandle()呼び出しでメソッドチェーンされている。

handle()のためのそれぞれのcallは、テンプレートパラメータとしてメッセージタイプを表します。そして、それから、lambda関数へと渡される。

なぜならば、これらの呼び出しはメソッドチェーンとされているので、wait()はdigit_pressedメッセージを待ち、clear_last_pressedメッセージを待ち、cancel_pressedメッセージが入力されることを待ちます。その他のタイプは捨てられることになります。

###
今回は、メッセージを取得した際には状態を変化させる必要はない。
例えば、もしdigit_pressedメッセージを取得したら、最後のdigitまではただpinに追加するだけでよい。listing4.15中のmail loopは次のdigitが呼ばれるまでgetting_pin()を呼び出します。

###
これはfigure 4.3に示された振る舞いと一致する。
どちらの状態ボックスも区別されたメンバー関数(関連したメッセージを待ち、適切な時に状態を更新する)によって実装される。

### 
みてきたように、このスタイルのプログラミングはconcurrent systemの設計を非常に単純化してきた。
なぜならば、各種スレッドが完全に独立して扱われてきたからだ。
これは、マルチスレッドを関心で分割する利用する例です。そして、どのようにスレッドあいだのタスクを分割するのかといったことを明示的に要求します。

