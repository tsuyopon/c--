# 6.2.2 A thread-safe queue using locks and condition variables

chap4からのスレッドセーフなキューはlisting6.2として複製して記載しています。

push()関数中にdata_cond.notify_one()があるのと、wait_and_pop()関数があるのを除いてはlisting6.1と似ています。

2つのオーバーロードであるtry_pop()は、queueが空だったら例外を投げないという違いを除いてはlisting6.1のpop()はほとんど同じです。

変わりに、それらは値が取得されたか、NULLポインターだったかどうかを示すbool値を戻します。

これは、stackを実装する上で妥当な方法です。
もしwait_and_pop()関数を除いた場合、stackへの分析はここでも同様にし次のように適用されます。

新しいwait_and_pop()関数はstack中にあるキューエントリを待つための解決策である。
empty()を呼び続けるよりも、待っているスレッドはただwait_and_pop()を呼び、データ構造は状態変数とともに待ち状態をハンドリングする。
data_cond.wait()の呼び出しは、キューが１つの要素でも存在するまでは値を戻しません。

コード中のこのwaitが戻ってきた時点でキューが空となる可能性を心配する必要はありません。そして、データはmutex上のロックで守られています。
これらの関数はそれゆえに新しいレースコンディションやデッドロックの可能性が追加されることはありません。

exceptionセーフの点に関してわずかながらtwistがあります。次の点で説明します。
もし、１つ以上のスレッドがキューにエントリーをpushする際に待っているとして、1つのスレッドがdata_cond.notify_one()によって呼び起こされることになるでしょう。

しかし、wait_and_pop()中でそのスレッドがthrowするとき(たとえば、新しいstd::shared_ptr<>がconstructされる際に)、他のスレッドが呼び起こされることはないでしょう。
もしこれが受け入れられないのであれば、呼び出しは容易にdata_cond.notify_all()へと置換することができる。
それは、すべてのスレッドを起こすが、キューが結局空だった場合にはsleep()状態へと戻されるパフォーマンスコストが代償となります。

第２の選択肢は、もし例外が投げられたら他のスレッドが蓄積された値に取得できるように、wait_and_pop()とnotify_one()を持つことです。

第３の選択肢は、std::shared_ptr<>の初期化をpush()へと移動したり、直接的な値ではなくstd::shared_ptr<> インスタンスをストアすることです。
std::queue<>の中にstd::shared_ptr<>をコピーすることで、例外は投げられません。よって、wait_and_pop()もまた安全です。

Listing6.3.ccはこの第３の選択肢に基づいて修正されたキュー実装です。

```
<Listing6.3>ソースコード
```

std::shared_ptr<>によるデータは直感的です。
変数の参照を受け取るpop()関数は、ポインタへのデリファレンスを持たなければならない。
そして、std::shared_ptr<>インスタンスを返すpop()は呼び出し元へ返す前に、キューから回収することができます。

データがstd::shared_ptr<>によって掴まれていたら、さらなる利点があります。
新しいインスタンスの割当はpush()中のロックの外で行われます。
一方で、listing6.2において、pop()中でロックが取得されている間に発生します。
なぜならば、メモリ割り当ては極めてコストが高いオペレーションだからです。
これは、キューのパフォーマンスにとって非常に利点ががあります。
なぜならば、mutexが掴まれている間の時間を削減し、その間キュー上のオペレーション操作を他のスレッドに許容します。

ちょうど、Figure6.1のようなstackサンプルとなります。
すべてのデータ構造を守るためのmutexを使用することは、キューによってサポートされるconcurrencyを制限します。
複数のスレッドは様々なメンバー関数内でキューをブロックするかもしれません。
１つのスレッドだけが一度になにかの仕事を実行できる。
しかしながら、この制限の一部は実装にstd::queue<>を使用することから発生します。
標準コンテナを利用することによって、保護されていようが、いまいが１つのアイテムのみを保持することになる。

データ構造の詳細実装を統制することによって、あなたは細かいlockを提供することができる。そして、それにより高度なレベルでのconcurrencyを許可するようになります。



# まとめ
スレッドセーフなキューの実装(listing6.2.cc)を確認しました。
しかし、listing6.2.cc だと、throwされた場合の処理で他のスレッドが稼動しなくなる可能性があるという気づきにくい問題があります。
throwされない別の方法として３つの選択肢がありましたが、その中でstd::queueにstd::shared_ptrで包むことによってthrowを投げないようにすることでこの問題を解決しました。


