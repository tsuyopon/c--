# 6章で扱うこと
- concurrencyのためのデータ構造設計は何を意味するのか?
- 上記をするためのガイドライン
- concurrency設計のためのデータ構造のサンプル実装

# 6.1.1 Guidelines for designing data structures for concurrency

concurrentにアクセスをするためのデータ構造設計をする際には、次の２つの側面を考えるべきである。
- A. アクセスがsafeであることの保証
- B. concurrencyなアクセスが本物であることの保証


### Aについて

chapter3ではデータ構造をスレッドセーフにするための基本について説明した。
- 1. 他のスレッドのアクションによってデータ構造の異型となった壊れた状態のデータが他のスレッドから見えないことを保証すること。
- 2. オペレーションステップよりもむしろ完全な操作のための関数を提供することによって、インターフェース固有のデータ構造へのレースコンディションを避けるように気をつけること
- 3. データ構造がの異型となった壊れた状態とならないことを保証するために、例外の存在においてデータ構造の振る舞いをどのようにするか注意を払うこと
- 4. スコープのあるロックの構築とネストされたロックを避けることによって、データ構造を使う際にデッドロックのための機会を最小化する。

上記の詳細を考える前に、何の制約をデータ構造に課したいかということを考えるのは重要です。
たとえば、もし１つのスレッドが特有の関数を通じてデータ構造へアクセスしているとき、どの関数が他のスレッドから呼び出しても安全かということです。
一般的には、コンストラクタやデストラクタはデータ構造への排他的なアクセスを必要とします。
しかし、コンストラクタの完了前やデストラクタ開始後ににデータ構造へアクセスしないことを保証するのはユーザー次第である。


もし、データ構造がassignment, swap(), copy constructionをサポートしていたのなら、
それらのオペレーション処理が他のオペレーションとconcurrentに呼び出した際に安全であるかどうかを決める必要があります。
また、それらはユーザーに排他的なアクセスの保証を必要とするかどうかを決める必要があります。そのデータ構造を操作するための大多数の関数が問題なくconcurrentに複数スレッドから呼び出されるかもしれないとしても


### Bについて
2番目の質問についてはガイドラインとしては多くのことを提供できないが、次のような疑問を考えると良い。
・1. ロックのスコープは、ロックの外でも稼動できるようなオペレーションが稼動することを許容するように制限しているか
・2. 異なったデータ部分については、異なったmutexで守られているか?
・3. すべてのオペレーションは同じレベルの保護を必要としているか? (XXX)
・4. データ構造への単純な変化は操作的意味に影響を与えることなくconcurrencyのために機会を与えることができるか?  (XXX)


複数スレッドからのconcurrentなデータ構造の読み込みをサポートし、一方でデータ構造を修正する際には排他的に操作するといった場合にはboost::shared_mutexがサポートされている。

