# 6章で扱うこと
- concurrencyのためのデータ構造を設計すること
- 上記をするためのガイドライン
- concurrency設計のためのデータ構造のサンプル実装

# 6.1.1 Guidelines for designing data structures for concurrency

concurrentにアクセスをするためのデータ構造設計をする際には、次の２つの側面を考えるべきである。
- A. アクセスがsafeであることの保証
- B. concurrencyなアクセスが本物であることの保証


### Aについて

chapter3ではデータ構造をスレッドセーフにするための基本について説明した。
- 1. 他のスレッドのアクションによってデータ構造の異型となった壊れた状態のデータが他のスレッドから見えないことを保証すること。
- 2. オペレーションステップよりもむしろ完全な操作のための関数を提供することによって、インターフェース固有のデータ構造へのレースコンディションを避けるように気をつけること
- 3. データ構造がの異型となった壊れた状態とならないことを保証するために、例外の存在においてデータ構造の振る舞いをどのようにするか注意を払うこと
- 4. スコープのあるロックによる制約と可能な限りネストされたロックを避けることによって、データ構造を使う際にデッドロックが発生する可能性を最小化する。

上記の詳細を考える前に、何の制約をユーザーに課したいかということを考えるのは重要です。
たとえば、もし１つのスレッドが特有の関数を通じてデータ構造へアクセスしているとき、どの関数が他のスレッドから呼び出しても安全かということです。
一般的には、コンストラクタやデストラクタはデータ構造への排他的なアクセスを必要とします。
しかし、コンストラクタの完了前やデストラクタ開始後ににデータ構造へアクセスしないことを保証するのはユーザー次第となっています。


もし、データ構造がassignment, swap(), copy constructionをサポートしていたのなら、
それらのオペレーション処理が他のオペレーションとconcurrentに呼び出した際に安全であるかどうかを決める必要があります。
そのデータ構造を操作するための大多数の関数が問題なくconcurrentに複数スレッドから呼び出されるかもしれないとして、 ユーザーに排他的なアクセスの保証を必要とするかどうかを判断が必要となります。


### Bについて
2番目の質問についてはガイドラインとしては多くのことを提供できないが、次のような疑問を考えると良い。
- 1. ロックのスコープは、ロックの外でも稼動できるようなオペレーションに対してはロックのスコープ外で稼動するようにしているか
- 2. 異なったデータ部分については、異なったmutexで守られているか?
- 3. すべてのオペレーションは同一レベルの保護を必要としているか?
- 4. データ構造への単純な変化は操作的意味に影響を与えることなくconcurrencyが実現されるようになっているのか?

複数スレッドからのconcurrentなデータ構造の読み込みをサポートし、一方でデータ構造を修正する際には排他的に操作するといった場合にはboost::shared_mutexがサポートされている。

