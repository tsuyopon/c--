# 6.2.1 A thread-safe stack using locks

どのようにガイドラインが適用されているのかを見ていくことにしましょう。

最初に
スレッドセーフであることが各関数においてmutex変数mのロックを用いることで実現されている。
これによって1度に１スレッドしかデータ構造にアクセスできないことを保証し、どのスレッドからも壊れたデータを見ることがなくなる。

第２に
emptyと2つのpop関数の間にはレースコンディションが可能性があります。
しかし、popでロックされている間にemptyであるかどうかの明示的なチェックをおこなっているので、この問題は生じません。
pop関数の呼び出しによりポップされたアイテムを直接戻すことによって、top()とpop()に分割されたレースコンディションの状態を避けることができるようになります。


第３に
いくつかの例外に関するソースコードがあります。
mutexロックをするだけでexceptionが発生するかもしれない。しかし、これは非常に稀な事象であり、各関数の最初の処理でもある。
データは何も修正されていないので、これは安全である。
mutexのunlocking自体は失敗することはないので、これもまた安全である。
また、std::lock_guard<> の仕様はlockを残さないことを保証してくれます。

もしかしたら、data.push()の呼び出しは、copyやmodeまたはメモリの割当ができなかった場合やデータ構造に基づいて十分なメモリが存在しないような場合、exceptionを投げるかもしれません。
しかし、std::stack<>は安全であることを保証してくれるので、これもまた問題になりません。


最初のオーバーロード関数のpop()はempty_stackの例外を投げるかもしれませんが、何も修正されていませんので、これは安全です。
また、res変数の作成が次のような理由で例外が投げられるかもしれない。
- std::make_sharedが新しいデータオブジェクトや内部データのリファレンスカウントに対してメモリ割り当てができなくなった場合
- 新鮮なメモリ割り当てを必要とするときに、copy constructor、move constructorなどの場合
上記どちらのケースにしてもC++ runtimeとStandard Libraryはメモリリークを起こさないことを保証します。また、新しいオブジェクトは正しくdestroyされることも保証します。
なぜならば、stackをまだ修正していないからです。
data.pop()はthrowしないことが保証されています。よって、exception-safeであることが保証されます。


2番目のオーバーロード関数のpop()は、先程のpop()に似ています。
最初のpop()では新しいオブジェクトの構築やstd::shared_ptrインスタンスを利用していたのに対して、今回の場合はcopy assignmentとmove assignmentが行われています。
最初のpop()と同様にdata.pop()を呼ぶまでデータ構造を修正していないので、これもthrowされないことが保証されるので、この場合もexception-safeです。
最後に、empty()もデータを修正しないので、これもexception-safeです。


いくつかのデッドロックを起こす可能性がある箇所があります。なぜなら、ロックを掴んでいる間にユーザーコードを呼び出すからです。
newなどと同様に、データアイテムが含まれたcopyコンストラクタ、moveコンストラクタ、copy assignment、move assignmentなどがあります。
これらの関数がアイテムを挿入したり、削除したり、ある種のロックを取るようなスタック上のメンバー関数を呼び出す場合やスタックメンバ関数が呼ばれた際に他のロックが抱えられてしまうような場合には、デッドロックを引き起こす可能性があります。
しかしながら、これらを保証してもらうことを要求するほうが懸命です。
copyやメモリ割り当てをすることなしにスタックへのアイテムの追加や削除はできないので。


すべてのメンバー関数はデータを守るためにstd::lock_guard<>を利用しているので、これはstackメンバー関数を呼び出すどんなスレッドに対しても安全です。
唯一安全でないと言えないのがコンストラクタとデストラクタです。が、これはあまり特有の問題ではりません。なぜなら、オブジェクトは１度だけ構築され、１度だけデストロイされてしまうからです。
不完全に構築されたオブジェクトや部分的にデストラクトされたオブジェクトのメンバー関数を呼び出すことはconcurrencyであろうがなかろうがよくありません。
その結果、他のスレッドが完全に構築されたり、すべてがデストラクトされるまですべてのスレッドのアクセスを中止することを保証しなくてはなりません。


スレッドのシリアライゼーション化はスタック上で競合するアプリケーションパフォーマンスの制限してきた。
スレッドはロックを待っているが、何も役に立つ仕事をしていない。
stackはアイテム待ちのために追加で他の手段を提供していない。
よって、もしスレッドが待つ必要があるのであれば、定期的にempty()かcall()を呼ばなければならない。そして、empty_stack例外を受け取らないとならない。

そのようなシナリオが要求される場合には、これはstack実装の選択肢を縮めてしまうかもしれない。
なぜならば、待ち状態のスレッドはデータのチェックのために貴重なリソースを使い、外部waitやnotificationコードを書かなくてはならない。
それは不必要に内部でロッキングを利用して、それゆえに無駄となっている。

chapter4から登場したqueueでは、状態変数を利用する実装を用いているので、次を見てみよう。

